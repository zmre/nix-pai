# Vulnerability Patterns Reference

This reference covers common vulnerability patterns organized by OWASP Top 10 categories, with language-specific examples.

---

## A01: Broken Access Control

### Missing Authorization Checks

**Rust (Actix-web):**
```rust
// VULNERABLE - No authorization check
#[get("/admin/users")]
async fn list_users() -> impl Responder {
    let users = db.get_all_users().await;
    HttpResponse::Ok().json(users)
}

// SECURE - Authorization middleware
#[get("/admin/users")]
async fn list_users(user: AuthenticatedUser) -> impl Responder {
    if !user.has_role(Role::Admin) {
        return HttpResponse::Forbidden().finish();
    }
    let users = db.get_all_users().await;
    HttpResponse::Ok().json(users)
}
```

**TypeScript (Express):**
```typescript
// VULNERABLE - No ownership check
app.delete('/api/posts/:id', async (req, res) => {
    await Post.delete(req.params.id);
    res.json({ success: true });
});

// SECURE - Verify ownership
app.delete('/api/posts/:id', async (req, res) => {
    const post = await Post.findById(req.params.id);
    if (post.authorId !== req.user.id) {
        return res.status(403).json({ error: 'Forbidden' });
    }
    await Post.delete(req.params.id);
    res.json({ success: true });
});
```

**Python (Flask):**
```python
# VULNERABLE - Direct object reference
@app.route('/api/documents/<doc_id>')
def get_document(doc_id):
    return Document.query.get(doc_id).to_json()

# SECURE - Check access permission
@app.route('/api/documents/<doc_id>')
@login_required
def get_document(doc_id):
    doc = Document.query.get_or_404(doc_id)
    if not current_user.can_access(doc):
        abort(403)
    return doc.to_json()
```

### Search Patterns

```bash
# Find endpoints without auth middleware
grep -rn "@app.route\|@get\|@post" --include="*.py" | grep -v "login_required\|authenticate"
grep -rn "app.get\|app.post\|router.get" --include="*.ts" | grep -v "auth\|middleware"
```

---

## A02: Cryptographic Failures

### Hardcoded Secrets

**Rust:**
```rust
// VULNERABLE - Hardcoded key
const API_KEY: &str = "sk-live-abc123";
const ENCRYPTION_KEY: &[u8] = b"hardcoded-key-32bytes!!!!!!!!!!!";

// SECURE - Environment variable
let api_key = std::env::var("API_KEY").expect("API_KEY must be set");
```

**TypeScript:**
```typescript
// VULNERABLE - Hardcoded in source
const JWT_SECRET = 'super-secret-key';

// SECURE - From environment
const JWT_SECRET = process.env.JWT_SECRET;
if (!JWT_SECRET) throw new Error('JWT_SECRET required');
```

### Weak Algorithms

```rust
// VULNERABLE - MD5 for passwords
use md5::Digest;
let hash = md5::compute(password);

// SECURE - Argon2 for passwords
use argon2::{Argon2, PasswordHasher};
let hash = Argon2::default()
    .hash_password(password.as_bytes(), &salt)?
    .to_string();
```

### Insecure Random

```typescript
// VULNERABLE - Math.random for security
const token = Math.random().toString(36);

// SECURE - Crypto random
import { randomBytes } from 'crypto';
const token = randomBytes(32).toString('hex');
```

### Search Patterns

```bash
# Find hardcoded secrets
grep -rn "api[_-]?key\s*=\s*['\"]" --include="*.{rs,ts,js,py}"
grep -rn "password\s*=\s*['\"]" --include="*.{rs,ts,js,py}"
grep -rn "secret\s*=\s*['\"]" --include="*.{rs,ts,js,py}"

# Find weak algorithms
grep -rn "md5\|sha1\|des\|rc4" --include="*.{rs,ts,js,py}"
grep -rn "Math.random" --include="*.{ts,js}"
```

---

## A03: Injection

### SQL Injection

**Rust (sqlx):**
```rust
// VULNERABLE - String concatenation
let query = format!("SELECT * FROM users WHERE name = '{}'", user_input);
let users = sqlx::query(&query).fetch_all(&pool).await?;

// SECURE - Parameterized query
let users = sqlx::query("SELECT * FROM users WHERE name = $1")
    .bind(user_input)
    .fetch_all(&pool)
    .await?;
```

**TypeScript (Prisma):**
```typescript
// VULNERABLE - Raw query with interpolation
const result = await prisma.$queryRaw`SELECT * FROM users WHERE name = ${userInput}`;

// SECURE - Prisma ORM (parameterized automatically)
const users = await prisma.user.findMany({
    where: { name: userInput }
});
```

**Python (SQLAlchemy):**
```python
# VULNERABLE - String formatting
query = f"SELECT * FROM users WHERE name = '{user_input}'"
db.execute(query)

# SECURE - Parameterized query
query = text("SELECT * FROM users WHERE name = :name")
db.execute(query, {"name": user_input})
```

### Command Injection

**Rust:**
```rust
// VULNERABLE - Shell interpolation
let output = Command::new("sh")
    .arg("-c")
    .arg(format!("cat {}", filename))
    .output()?;

// SECURE - Direct execution with args
let output = Command::new("cat")
    .arg(filename)
    .output()?;
```

**TypeScript:**
```typescript
// VULNERABLE - Shell execution
const { exec } = require('child_process');
exec(`cat ${filename}`, callback);

// SECURE - execFile with args array
const { execFile } = require('child_process');
execFile('cat', [filename], callback);
```

### Path Traversal

**Rust:**
```rust
// VULNERABLE - Unvalidated path
let path = format!("/uploads/{}", user_filename);
std::fs::read(path)?;

// SECURE - Canonicalize and validate
use std::path::Path;
let base = Path::new("/uploads").canonicalize()?;
let user_path = base.join(user_filename).canonicalize()?;
if !user_path.starts_with(&base) {
    return Err("Path traversal detected");
}
std::fs::read(user_path)?;
```

### Search Patterns

```bash
# SQL injection
grep -rn "format!\|format\(" --include="*.rs" | grep -i "select\|insert\|update\|delete"
grep -rn "f\".*SELECT\|f\".*INSERT" --include="*.py"
grep -rn "\`.*\${.*}\`" --include="*.ts" | grep -i "select\|insert"

# Command injection
grep -rn "Command::new.*sh\|exec\|spawn" --include="*.rs"
grep -rn "exec(\|execSync\|spawn\(" --include="*.{ts,js}"
grep -rn "os.system\|subprocess.call\|Popen" --include="*.py"

# Path traversal
grep -rn "Path::new.*join\|path.join" --include="*.rs"
grep -rn "path.join\|fs.readFile" --include="*.{ts,js}"
```

---

## A04: Insecure Design

### Missing Rate Limiting

**Rust (Actix-web):**
```rust
// VULNERABLE - No rate limiting on login
#[post("/login")]
async fn login(credentials: Json<Credentials>) -> impl Responder {
    // Attempt authentication
}

// SECURE - With rate limiter
use actix_governor::{Governor, GovernorConfigBuilder};

let config = GovernorConfigBuilder::default()
    .per_second(5)
    .burst_size(10)
    .finish()
    .unwrap();

#[post("/login")]
async fn login(credentials: Json<Credentials>, rate: Governor) -> impl Responder {
    // Rate limited authentication
}
```

### Missing Input Validation

```typescript
// VULNERABLE - No schema validation
app.post('/api/user', async (req, res) => {
    await User.create(req.body);
});

// SECURE - Zod schema validation
import { z } from 'zod';

const UserSchema = z.object({
    email: z.string().email(),
    name: z.string().min(1).max(100),
    age: z.number().int().positive().max(150),
});

app.post('/api/user', async (req, res) => {
    const validated = UserSchema.parse(req.body);
    await User.create(validated);
});
```

### Search Patterns

```bash
# Missing validation
grep -rn "req.body\|request.body" --include="*.{ts,js}" | grep -v "validate\|schema\|zod"
grep -rn "Json<\|web::Json" --include="*.rs" | grep -v "Validate"
```

---

## A05: Security Misconfiguration

### Debug Mode in Production

```python
# VULNERABLE
app.run(debug=True)

# SECURE
app.run(debug=os.environ.get('DEBUG', 'False').lower() == 'true')
```

### Missing Security Headers

```typescript
// VULNERABLE - No security headers
app.listen(3000);

// SECURE - Helmet middleware
import helmet from 'helmet';
app.use(helmet());
```

### Permissive CORS

```rust
// VULNERABLE - Allow all origins
.wrap(Cors::permissive())

// SECURE - Specific origins
.wrap(
    Cors::default()
        .allowed_origin("https://myapp.com")
        .allowed_methods(vec!["GET", "POST"])
)
```

### Search Patterns

```bash
# Debug mode
grep -rn "debug=True\|DEBUG=true" --include="*.{py,rs,ts,js,json,yaml,yml}"

# Permissive CORS
grep -rn "permissive\|Access-Control-Allow-Origin.*\*" --include="*.{rs,ts,js,py}"
```

---

## A06: Vulnerable Components

Use dependency audit commands from `dependency-audit.md`.

---

## A07: Authentication Failures

### Weak Password Hashing

```python
# VULNERABLE - Plain MD5
import hashlib
hash = hashlib.md5(password.encode()).hexdigest()

# SECURE - Bcrypt/Argon2
from passlib.hash import argon2
hash = argon2.hash(password)
```

### Session Fixation

```typescript
// VULNERABLE - Session ID unchanged after login
app.post('/login', (req, res) => {
    if (authenticate(req.body)) {
        req.session.user = user;
    }
});

// SECURE - Regenerate session
app.post('/login', (req, res) => {
    if (authenticate(req.body)) {
        req.session.regenerate((err) => {
            req.session.user = user;
        });
    }
});
```

### Search Patterns

```bash
# Weak hashing
grep -rn "md5\|sha1" --include="*.{rs,ts,js,py}" | grep -i "password\|hash"

# Session handling
grep -rn "session\[.*\]\s*=" --include="*.py"
grep -rn "req.session\." --include="*.{ts,js}"
```

---

## A08: Software and Data Integrity

### Unsigned Updates

```rust
// VULNERABLE - No signature verification
let update = download_update(url)?;
apply_update(update)?;

// SECURE - Verify signature
let update = download_update(url)?;
let signature = download_signature(sig_url)?;
verify_signature(&update, &signature, &public_key)?;
apply_update(update)?;
```

### Missing Dependency Lock

Check for presence of:
- `Cargo.lock` (Rust)
- `package-lock.json` or `bun.lockb` (JavaScript)
- `poetry.lock` or `uv.lock` (Python)

---

## A09: Security Logging

### Sensitive Data in Logs

```python
# VULNERABLE - Logging password
logger.info(f"Login attempt: {username}:{password}")

# SECURE - Redact sensitive data
logger.info(f"Login attempt: {username}:****")
```

### Missing Audit Logging

```rust
// Should log:
// - Authentication successes/failures
// - Authorization failures
// - Input validation failures
// - Security-relevant configuration changes

tracing::info!(
    user_id = %user.id,
    action = "login_success",
    ip = %req.peer_addr(),
    "User authenticated successfully"
);
```

### Search Patterns

```bash
# Sensitive data in logs
grep -rn "log\|print\|console" --include="*.{rs,ts,js,py}" | grep -i "password\|secret\|token\|key"
```

---

## A10: Server-Side Request Forgery (SSRF)

### Unvalidated URL Fetching

```rust
// VULNERABLE - Fetches any URL
async fn fetch_url(url: &str) -> Result<String> {
    reqwest::get(url).await?.text().await
}

// SECURE - Validate URL
async fn fetch_url(url: &str) -> Result<String> {
    let parsed = Url::parse(url)?;

    // Block internal addresses
    let host = parsed.host_str().ok_or("No host")?;
    if is_internal_host(host) {
        return Err("Internal URLs not allowed");
    }

    // Only allow HTTPS
    if parsed.scheme() != "https" {
        return Err("Only HTTPS allowed");
    }

    reqwest::get(url).await?.text().await
}

fn is_internal_host(host: &str) -> bool {
    host == "localhost"
        || host == "127.0.0.1"
        || host.starts_with("10.")
        || host.starts_with("192.168.")
        || host.starts_with("172.")
        || host.ends_with(".internal")
}
```

### Search Patterns

```bash
# URL fetching
grep -rn "reqwest::get\|fetch\|http.get\|requests.get" --include="*.{rs,ts,js,py}"
grep -rn "user.*url\|input.*url" --include="*.{rs,ts,js,py}"
```

---

## Quick Grep Commands

```bash
# All injection patterns
grep -rn "format!\|f\"\|`\${" --include="*.{rs,ts,js,py}" | grep -i "sql\|query\|select"

# All hardcoded secrets
grep -rn "key\s*=\s*['\"][a-zA-Z0-9]" --include="*.{rs,ts,js,py}"

# All shell commands
grep -rn "Command::new\|exec\|spawn\|system\|popen" --include="*.{rs,ts,js,py}"

# All file operations with user input
grep -rn "open\|read\|write" --include="*.{rs,ts,js,py}" | grep -v "test"

# All HTTP requests
grep -rn "fetch\|request\|axios\|reqwest" --include="*.{rs,ts,js,py}"
```
